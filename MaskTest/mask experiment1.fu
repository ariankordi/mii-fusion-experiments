enum OriginPosition {
    Center,
    Right,
    Left
}

class MaskPartsDesc {
    const float TexScaleX = 0.88961464;
    const float TexScaleY = 0.9276675;

    float x;
    float y;
    float width;
    float height;
    float angle;
    OriginPosition origin;

    public void SetXY!(float xx, float yy)
    {
        x = xx;
        y = yy;
    }
    public void SetWidthHeight!(float w, float h)
    {
        width = w;
        height = h;
    }
    public void SetAngle!(float a) { angle = a; }
    public void SetOrigin!(OriginPosition o) { origin = o; }

    static float DegreeToRadian(float degree)
    {
        return degree * (Math.PI / 180.0);
    }

    public float[3][4] GetMoveMtx()
    {
        float[3] scale1;
        scale1[0] = width;
        scale1[1] = height;
        scale1[2] = 1.0;
        float[3] rotate;
        rotate[0] = 0.0;
        rotate[1] = 0.0;
        rotate[2] = DegreeToRadian(angle);
        float[3] scale2;
        scale2[0] = TexScaleX;
        scale2[1] = TexScaleY;
        scale2[2] = 1.0;
        float[3] translate;
        translate[0] = x;
        translate[1] = y;
        translate[2] = 0.0;

        float[3][4] mat;
        MatrixSetSRST(mat, scale1, rotate, scale2, translate);

        return mat;
    }

    /// Creates a 3x4 matrix following the transforms:
    /// Scale, Rotate, Scale, Translate
    static void MatrixSetSRST(
        /// Output matrix.
        float[3][4] mat,
        /// Logical scale (sx, sy, 1).
        float[3] scale1,
        /// Rotation (rx, ry, rz) in radians.
        float[3] rotRadians,
        /// Texture atlas scale (tx, ty, 1).
        float[3] scale2,
        /// Translation (x, y, z).
        float[3] translate)
    {
        // Calculate sines and cosines for rotation.
        float sinX = Math.Sin(rotRadians[0]);
        float sinY = Math.Sin(rotRadians[1]);
        float sinZ = Math.Sin(rotRadians[2]);
        float cosX = Math.Cos(rotRadians[0]);
        float cosY = Math.Cos(rotRadians[1]);
        float cosZ = Math.Cos(rotRadians[2]);
    
        // Apply scale1 and rotation. R * diag(scale1)
        mat[0][0] =  cosY * cosZ * scale1[0];
        mat[1][0] =  cosY * sinZ * scale1[0];
        mat[2][0] = -sinY *        scale1[0];
    
        mat[0][1] = (sinX * sinY * cosZ - cosX * sinZ) * scale1[1];
        mat[1][1] = (sinX * sinY * sinZ + cosX * cosZ) * scale1[1];
        mat[2][1] = (sinX * cosY)                      * scale1[1];
    
        mat[0][2] = (cosX * cosZ * sinY + sinX * sinZ) * scale1[2];
        mat[1][2] = (cosX * sinZ * sinY - sinX * cosZ) * scale1[2];
        mat[2][2] = (cosX * cosY)                      * scale1[2];
    
        // Apply scale2 on first three rows after rotation.
        mat[0][0] *= scale2[0];  mat[0][1] *= scale2[0];  mat[0][2] *= scale2[0];
        mat[1][0] *= scale2[1];  mat[1][1] *= scale2[1];  mat[1][2] *= scale2[1];
        mat[2][0] *= scale2[2];  mat[2][1] *= scale2[2];  mat[2][2] *= scale2[2];
    
        // Write translation axis.
        mat[0][3] = translate[0]; mat[1][3] = translate[1]; mat[2][3] = translate[2];
    }
}

#if JS
native
{
	const desc = new MaskPartsDesc();
	// eye L
	// x=170.596985, y=147.612183, width=162.449997, height=186.048004, angle=315.000000, origin=2,
	desc.setXY(170.596985, 147.612183);
	desc.setWidthHeight(162.449997, 186.048004);
	desc.setAngle(315.0);
	desc.setOrigin(OriginPosition.LEFT);

	const mtx = desc.getMoveMtx();
	console.log(mtx);
}
#endif